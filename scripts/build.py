#!/usr/bin/env python3
"""
N64 Tools Build Manager

This script manages the build process for N64 tools based on the projects.toml configuration.
It generates Makefiles and handles cross-platform building.
"""

import argparse
import platform
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Any
import toml


class BuildManager:
    def __init__(self, config_file: str = "projects.toml"):
        self.config_file = Path(config_file)
        self.config = self._load_config()
        self.detected_os = self._detect_os()
        self.build_settings = self.config.get("build_settings", {})
        self.source_groups = self.config.get("source_groups", {})
        self.projects = self.config.get("projects", {})
        self.libraries = self.config.get("libraries", {})

        # Set up build environment
        self.obj_dir = Path(self.build_settings.get("object_dir", "obj"))
        self.bin_dir = Path(self.build_settings.get("output_dir", "bin"))
        self.ext = ".exe" if self.detected_os == "windows" else ""

        # Cross-platform commands
        if self.detected_os == "windows":
            self.rm_cmd = "del /F /Q"
            self.rmdir_cmd = "rd /S /Q"
            self.mkdir_cmd = "mkdir"
        else:
            self.rm_cmd = "rm -f"
            self.rmdir_cmd = "rm -rf"
            self.mkdir_cmd = "mkdir -p"

        # Get brew prefix on macOS
        self.brew_prefix = ""
        if self.detected_os == "macos":
            try:
                result = subprocess.run(
                    ["brew", "--prefix"], capture_output=True, text=True
                )
                if result.returncode == 0:
                    self.brew_prefix = result.stdout.strip()
            except FileNotFoundError:
                pass

    def _load_config(self) -> Dict[str, Any]:
        """Load the TOML configuration file."""
        if not self.config_file.exists():
            print(f"Error: Configuration file {self.config_file} not found!")
            sys.exit(1)

        with open(self.config_file, "r", encoding="utf-8") as f:
            return toml.load(f)

    def _detect_os(self) -> str:
        """Detect the operating system."""
        system = platform.system().lower()
        if system == "windows":
            return "windows"
        elif system == "linux":
            return "linux"
        elif system == "darwin":
            return "macos"
        else:
            return "unknown"

    def _expand_source_groups(self, sources: List[str]) -> List[str]:
        """Expand source group references like $utils to actual file lists."""
        expanded = []
        for source in sources:
            if source.startswith("$"):
                group_name = source[1:]
                if group_name in self.source_groups:
                    expanded.extend(self.source_groups[group_name])
                else:
                    print(f"Warning: Unknown source group '{group_name}'")
            else:
                expanded.append(source)
                # Verify source file exists to catch typos
                if not Path(source).exists():
                    print(f"Warning: Source file not found: {source}")
        return expanded

    def _get_compiler_flags(self) -> str:
        """Generate compiler flags from configuration."""
        flags = []

        # Optimization level
        opt_level = self.build_settings.get("optimization_level", 3)
        flags.append(f"-O{opt_level}")

        # Warning flags
        warning_flags = self.build_settings.get("warning_flags", [])
        flags.extend(warning_flags)

        # Include directories
        include_dirs = self.build_settings.get("include_dirs", [])
        for inc_dir in include_dirs:
            flags.append(f"-I{inc_dir}")

        # Additional flags
        flags.extend(["-ffunction-sections", "-fdata-sections", "-MMD"])

        return " ".join(flags)

    def _get_linker_flags(self) -> str:
        """Generate linker flags based on OS."""
        if self.detected_os == "macos":
            return "-Wl,-dead_strip"
        else:
            return "-s -Wl,--gc-sections"

    def generate_makefile(self, output_file: str = "Makefile.generated"):
        """Generate a Makefile from the TOML configuration."""
        makefile_content = self._generate_makefile_content()

        with open(output_file, "w") as f:
            f.write(makefile_content)

        print(f"Generated {output_file}")

    def _generate_makefile_content(self) -> str:
        """Generate the complete Makefile content."""
        lines = []

        # Header and documentation
        lines.extend(
            [
                "# Generated Makefile for N64 Tools",
                "# This file is automatically generated from projects.toml",
                "# Do not edit directly - use 'python build.py generate-makefile' to regenerate",
                "",
                "# Usage:",
                "#   make               - Build all targets",
                "#   make <target>      - Build specific target",
                "#   make clean         - Remove build artifacts",
                "#   make list          - List all targets",
                "",
            ]
        )

        # Variables and OS detection
        lines.extend(
            [
                "# Build directories",
                f"OBJ_DIR = {self.obj_dir}",
                f"BIN_DIR = {self.bin_dir}",
                "",
                "# Compiler setup",
                "CC = $(CROSS)gcc",
                "LD = $(CC)",
                "AR = $(CROSS)ar",
                "",
                "# Build flags",
                f"CFLAGS = {self._get_compiler_flags()} $(DEFS)",
                f"LDFLAGS = {self._get_linker_flags()}",
                "",
            ]
        )

        # OS-specific settings
        lines.extend(
            [
                "# OS Detection",
                "ifeq ($(OS),Windows_NT)",
                "\tDETECTED_OS := windows",
                "\tEXT := .exe",
                f"\tRM := {self.rm_cmd}",
                f"\tRMDIR := {self.rmdir_cmd}",
                f"\tMKDIR := {self.mkdir_cmd}",
                "else",
                "\tUNAME_S := $(shell uname -s)",
                "\tifeq ($(UNAME_S),Linux)",
                "\t\tDETECTED_OS := linux",
                "\tendif",
                "\tifeq ($(UNAME_S),Darwin)",
                "\t\tDETECTED_OS := macos",
            ]
        )

        if self.brew_prefix:
            lines.extend(
                [
                    f"\t\tBREW_PREFIX := {self.brew_prefix}",
                    "\t\tCFLAGS += -I$(BREW_PREFIX)/include",
                    "\t\tLDFLAGS += -L$(BREW_PREFIX)/lib",
                ]
            )

        lines.extend(
            [
                "\tendif",
                "\tEXT :=",
                f"\tRM := {self.rm_cmd}",
                f"\tRMDIR := {self.rmdir_cmd}",
                f"\tMKDIR := {self.mkdir_cmd}",
                "endif",
                "",
            ]
        )

        # Target list
        main_targets = [
            name
            for name, config in self.projects.items()
            if config.get("include_in_all", True)
        ]
        lines.append(f"TARGETS := {' '.join(main_targets)}")
        lines.append("")

        # Library rules
        for lib_name, lib_config in self.libraries.items():
            lib_sources = self._expand_source_groups(lib_config["sources"])
            lib_objs = [f"$(OBJ_DIR)/{src[:-2] + '.o' if src.endswith('.c') else src + '.o'}" for src in lib_sources]

            lines.extend(
                [
                    f"# Library: {lib_config['name']}",
                    f"{lib_name.upper()}_OBJS = {' '.join(lib_objs)}",
                    f"{lib_config['name']}: $({lib_name.upper()}_OBJS)",
                    "\t$(AR) rcs $@ $^",
                    "",
                ]
            )

        # Build rules
        lines.extend(
            [
                "# Build rules",
                "default: all",
                "",
                "all: $(addprefix $(BIN_DIR)/,$(addsuffix $(EXT),$(TARGETS)))",
                "",
                "# General object file rule",
                "$(OBJ_DIR)/%.o: %.c",
                "\t@$(MKDIR) $(dir $@)",
                "\t@[ -d $(BIN_DIR) ] || $(MKDIR) $(BIN_DIR)",
                "\t$(CC) $(CFLAGS) -o $@ -c $<",
                "",
            ]
        )

        # Special compile rules for files with custom flags
        special_rules_added = set()
        for project_name, project_config in self.projects.items():
            special_flags = project_config.get("special_compile_flags", {})
            for source_file, flags in special_flags.items():
                if source_file not in special_rules_added:
                    obj_file = f"$(OBJ_DIR)/{source_file[:-2] + '.o' if source_file.endswith('.c') else source_file + '.o'}"
                    flag_str = " ".join(flags)
                    lines.extend(
                        [
                            f"{obj_file}: {source_file}",
                            "\t@$(MKDIR) $(dir $@)",
                            f"\t$(CC) $(CFLAGS) {flag_str} -o $@ -c $<",
                            "",
                        ]
                    )
                    special_rules_added.add(source_file)

        # Project build rules
        for project_name, project_config in self.projects.items():
            lines.extend(self._generate_project_rule(project_name, project_config))

        # Utility targets
        lines.extend(
            [
                "# Utility targets",
                "clean:",
                "\t$(RM) $(wildcard $(OBJ_DIR)/*/*.o) $(wildcard $(OBJ_DIR)/*/*.d)",
                "\t$(RM) $(addprefix $(BIN_DIR)/,$(addsuffix $(EXT),$(TARGETS)))",
                "\t-@[ -d $(OBJ_DIR) ] && $(RMDIR) $(OBJ_DIR) 2>/dev/null || true",
                "\t-@[ -d $(BIN_DIR) ] && $(RMDIR) $(BIN_DIR) 2>/dev/null || true",
                "",
                "list:",
                "\t@echo 'Available targets:'",
                "\t@echo '$(TARGETS)' | tr ' ' '\\n' | sort | sed 's/^/  /'",
                "",
                "help:",
                "\t@echo 'N64 Tools Build System (Generated)'",
                "\t@echo 'Usage:'",
                "\t@echo '  make          - Build all targets'",
                "\t@echo '  make <target> - Build specific target'",
                "\t@echo '  make clean    - Remove build artifacts'",
                "\t@echo '  make list     - List all targets'",
                "",
                ".PHONY: all clean default help list",
                "",
                "# Include dependency files",
                "-include $(wildcard $(OBJ_DIR)/*/*.d)",
            ]
        )

        return "\n".join(lines)

    def _generate_project_rule(
        self, project_name: str, project_config: Dict[str, Any]
    ) -> List[str]:
        """Generate Makefile rule for a specific project."""
        lines = []
        build_type = project_config.get("build_type", "lib_link")
        sources = self._expand_source_groups(project_config.get("sources", []))
        external_libs = project_config.get("external_libs", [])
        defines = project_config.get("defines", [])
        description = project_config.get("description", "")

        if description:
            lines.append(f"# {description}")

        target = f"$(BIN_DIR)/{project_name}$(EXT)"

        if build_type == "lib_link":
            # Links with library
            obj_files = [f"$(OBJ_DIR)/{src[:-2] + '.o' if src.endswith('.c') else src + '.o'}" for src in sources]
            deps = " ".join(obj_files)
            lib_deps = " ".join([f"{lib['name']}" for lib in self.libraries.values()])

            lines.extend(
                [
                    f"{target}: {deps} {lib_deps}",
                    f"\t$(LD) $(LDFLAGS) -o $@ $^ {self._format_external_libs(external_libs)}",
                ]
            )

        elif build_type == "object_link":
            # Uses object files but no library
            obj_files = [f"$(OBJ_DIR)/{src[:-2] + '.o' if src.endswith('.c') else src + '.o'}" for src in sources]
            deps = " ".join(obj_files)

            if external_libs and self.detected_os == "macos":
                lines.extend(
                    [
                        f"{target}: {deps}",
                        "ifeq ($(DETECTED_OS),macos)",
                        f"\t$(LD) $(LDFLAGS) -o $@ $^ -L$(BREW_PREFIX)/lib {self._format_external_libs(external_libs)}",
                        "else",
                        f"\t$(LD) $(LDFLAGS) -o $@ $^ {self._format_external_libs(external_libs)}",
                        "endif",
                    ]
                )
            else:
                lines.extend(
                    [
                        f"{target}: {deps}",
                        f"\t$(LD) $(LDFLAGS) -o $@ $^ {self._format_external_libs(external_libs)}",
                    ]
                )

        elif build_type == "standalone":
            # Compiles directly from sources
            src_files = " ".join(sources)
            define_flags = " ".join(defines)

            if external_libs and self.detected_os == "macos":
                lines.extend(
                    [
                        f"{target}: {src_files}",
                        "ifeq ($(DETECTED_OS),macos)",
                        f"\t$(CC) $(CFLAGS) {define_flags} $^ $(LDFLAGS) -o $@ -L$(BREW_PREFIX)/lib {self._format_external_libs(external_libs)}",
                        "else",
                        f"\t$(CC) $(CFLAGS) {define_flags} $^ $(LDFLAGS) -o $@ {self._format_external_libs(external_libs)}",
                        "endif",
                    ]
                )
            else:
                lines.extend(
                    [
                        f"{target}: {src_files}",
                        f"\t$(CC) $(CFLAGS) {define_flags} $^ $(LDFLAGS) -o $@ {self._format_external_libs(external_libs)}",
                    ]
                )

        lines.append("")
        return lines

    def _format_external_libs(self, libs: List[str]) -> str:
        """Format external library flags."""
        if not libs:
            return ""
        return " ".join([f"-l{lib}" for lib in libs])

    def list_projects(self):
        """List all available projects."""
        print("Available projects:")
        for name, config in self.projects.items():
            description = config.get("description", "")
            build_type = config.get("build_type", "")
            include_in_all = config.get("include_in_all", True)
            status = "" if include_in_all else " (utility)"
            print(f"  {name:<15} {build_type:<12} {description}{status}")

    def build_project(self, project_name: str, **kwargs):
        """Build a specific project."""
        if project_name not in self.projects:
            print(f"Error: Project '{project_name}' not found!")
            return False

        # Generate fresh Makefile
        self.generate_makefile()

        # Build using make
        cmd = ["make", "-f", "Makefile.generated", project_name]

        # Add any additional make flags
        if "opt_level" in kwargs:
            cmd.extend([f"OPTFLAG={kwargs['opt_level']}"])
        if "cross_prefix" in kwargs:
            cmd.extend([f"CROSS={kwargs['cross_prefix']}"])

        print(f"Building {project_name}...")
        result = subprocess.run(cmd)
        return result.returncode == 0

    def build_all(self, **kwargs):
        """Build all projects."""
        # Generate fresh Makefile
        self.generate_makefile()

        # Build using make
        cmd = ["make", "-f", "Makefile.generated", "all"]

        # Add any additional make flags
        if "opt_level" in kwargs:
            cmd.extend([f"OPTFLAG={kwargs['opt_level']}"])
        if "cross_prefix" in kwargs:
            cmd.extend([f"CROSS={kwargs['cross_prefix']}"])

        print("Building all projects...")
        result = subprocess.run(cmd)
        return result.returncode == 0

    def clean(self):
        """Clean build artifacts."""
        if self.obj_dir.exists():
            shutil.rmtree(self.obj_dir)
        if self.bin_dir.exists():
            shutil.rmtree(self.bin_dir)

        # Clean generated files
        for generated_file in ["Makefile.generated", "libn64.a"]:
            if Path(generated_file).exists():
                Path(generated_file).unlink()

        print("Cleaned build artifacts")

    def add_project(
        self,
        name: str,
        sources: List[str],
        build_type: str = "lib_link",
        description: str = "",
        **kwargs,
    ):
        """Add a new project to the configuration."""
        if name in self.projects:
            print(f"Error: Project '{name}' already exists!")
            return False

        project_config = {
            "sources": sources,
            "build_type": build_type,
            "description": description,
        }

        # Add optional fields
        for key, value in kwargs.items():
            if value:  # Only add non-empty values
                project_config[key] = value

        # Create source directory if it doesn't exist
        src_dir = Path(f"src/{name}")
        if not src_dir.exists():
            src_dir.mkdir(parents=True)

            # Create basic template
            template_file = src_dir / f"{name}.c"
            with open(template_file, "w") as f:
                f.write(
                    f"""#include <stdio.h>
#include <stdlib.h>
#include "utils.h"

int main(int argc, char *argv[])
{{
    printf("Hello from {name}!\\n");
    return 0;
}}
"""
                )
            print(f"Created template: {template_file}")

        # Update TOML file (simplified - in practice you'd want a proper TOML writer)
        print(f"Project '{name}' configuration ready.")
        print("Please manually add the following to projects.toml:")
        print(f"\n[projects.{name}]")
        print(f"sources = {sources}")
        print(f'build_type = "{build_type}"')
        if description:
            print(f'description = "{description}"')
        for key, value in kwargs.items():
            if value:
                print(f"{key} = {repr(value)}")

        return True


def main():
    parser = argparse.ArgumentParser(description="N64 Tools Build Manager")
    parser.add_argument("--config", default="projects.toml", help="Configuration file")

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Generate Makefile command
    gen_parser = subparsers.add_parser(
        "generate-makefile", help="Generate Makefile from TOML"
    )
    gen_parser.add_argument(
        "--output", default="Makefile.generated", help="Output Makefile path"
    )

    # List projects command
    subparsers.add_parser("list", help="List all projects")

    # Build commands
    build_parser = subparsers.add_parser("build", help="Build project(s)")
    build_parser.add_argument("project", nargs="?", help="Project name (omit for all)")
    build_parser.add_argument("--opt", type=str, help="Optimization level")
    build_parser.add_argument("--cross", type=str, help="Cross-compiler prefix")

    # Clean command
    subparsers.add_parser("clean", help="Clean build artifacts")

    # Add project command
    add_parser = subparsers.add_parser("add", help="Add new project")
    add_parser.add_argument("name", help="Project name")
    add_parser.add_argument("--sources", nargs="+", help="Source files")
    add_parser.add_argument(
        "--type", default="lib_link", choices=["lib_link", "object_link", "standalone"]
    )
    add_parser.add_argument("--description", help="Project description")
    add_parser.add_argument("--libs", nargs="+", help="External libraries")
    add_parser.add_argument("--defines", nargs="+", help="Preprocessor defines")

    args = parser.parse_args()

    # Default to generate-makefile if no command specified
    if not args.command:
        args.command = "generate-makefile"

    build_manager = BuildManager(args.config)

    if args.command == "generate-makefile":
        output = getattr(args, "output", "Makefile.generated")
        build_manager.generate_makefile(output)

    elif args.command == "list":
        build_manager.list_projects()

    elif args.command == "build":
        kwargs = {}
        if hasattr(args, "opt") and args.opt:
            kwargs["opt_level"] = args.opt
        if hasattr(args, "cross") and args.cross:
            kwargs["cross_prefix"] = args.cross

        if hasattr(args, "project") and args.project:
            success = build_manager.build_project(args.project, **kwargs)
        else:
            success = build_manager.build_all(**kwargs)

        sys.exit(0 if success else 1)

    elif args.command == "clean":
        build_manager.clean()

    elif args.command == "add":
        sources = args.sources or [f"src/{args.name}/{args.name}.c", "$utils"]
        kwargs = {}
        if args.libs:
            kwargs["external_libs"] = args.libs
        if args.defines:
            kwargs["defines"] = args.defines

        build_manager.add_project(
            args.name, sources, args.type, args.description or "", **kwargs
        )


if __name__ == "__main__":
    main()
